---
layout: post
title: CTF-逆向PWN总结02
categories: 
 - CTF
 - 二进制
permalink: /posts/2
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# 汇编基础总结

## 寄存器介绍

寄存器是在cpu中的一个存储空间，可以用于存储一定的值。在已有的文章大多数会讲述16位寄存器，而这里就直接介绍一下32位寄存器，其实两种寄存器很多地方是相似的。

32位寄存器一共有14个 寄存器，总体分类个数如下：

- 4个数据寄存器
- 2个变址寄存器
- 2个指针寄存器
- 6个段寄存器
- 1个指令指针寄存器
- 1个标志寄存器

### 数据寄存器：

数据寄存器主要用于保存操作数和运算结果等信息，这里跟一个变量类似。

32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。

4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。

**AX**寄存器：常称为累加器，累加器进行操作可能更省时间。累加器可用于乘/除、输入输出等操作，使用频率很高。

**BX**寄存器：称为基地址寄存器，可作为存储器指针来使用。

**CX**寄存器：计数寄存器，在循环和字符串操作时，用来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数。

**DX**寄存器：数据寄存器，在进行乘除运算时，作为默认的操作数参和运算，也可以用于存放I/O的端口地址。

### 变址寄存器：

32位寄存器**ESI**和**EDI**所对应16位中的SI和DI，对低16位数据的存储，不影响高16位的数据。

寄存器ESI、EDI、SI和DI称为变址寄存器，主要用于存放存储单元在段内的偏移量，用他们可以实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。

### 指针寄存器：

寄存器EBP、ESP、BP和SP称为指针寄存器，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。

**BP**为基指针寄存器，用它可直接存取堆栈中的数据；
**SP**为堆栈指针寄存器，用它只可访问栈顶。

### 段寄存器：

段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。

**CS**：代码段寄存器，其值为代码段的段值；
**DS**：数据段寄存器，其值为数据段的段值；
**ES**：附加段寄存器，其值为附加数据段的段值；
**SS**：堆栈段寄存器，其值为堆栈段的段值；
**FS**：附加段寄存器，其值为附加数据段的段值；
**GS**：附加段寄存器，其值为附加数据段的段值。

在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。

32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简单描述如下：
实方式：
前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为“段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。
保护方式：
在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为“选择子”的某个值。

### 指令指针寄存器：

32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。

指令指针**EIP**、**IP**是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。
在实方式下，由于每个段的最大范围为64K，所以，EIP中的高16位肯定都为0，此时，相当于只用其低16位的IP来反映程序中指令的执行次序。

### 标志寄存器：

1. 进位标志**CF**：

   进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。
   使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。

2. 奇偶标志**PF**：
   奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。
   利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。

3. 辅助进位标志**AF**：
   在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：
   ​	(1)、在字操作时，发生低字节向高字节进位或借位时；
   ​	(2)、在字节操作时，发生低4位向高4位进位或借位时。
   对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。

4. 零标志**ZF**：
   零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。

5. 符号标志**SF**：
   符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。

6. 溢出标志**OF**：
   溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。

## 汇编语句基础

### 基本运算语句：

### 逻辑运算语句：

### 控制语句：

## 总结

经过分解gcc编译每个过程，清楚一个程序的编译过程，此文章主要根据的是文件生成类型进行分析。而不是详细的分析编译器编译文件过程，编译器编译文件过程需要更多编译原理的知识，但是在目前考虑范围中，不需要接触到。之后又简单的介绍elf文件结构，在之后修改程序时能更好的理解。