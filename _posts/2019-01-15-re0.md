---
layout: post
title: CTF-逆向PWN总结01
categories: 
 - CTF
 - 二进制
permalink: /posts/1
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# 逆向基础总结

## C语言编译过程

主要通过LINUX下C语言编译过程为例。

编写一个最简单的例子：

```c
//hello.c
#include <stdio.h>
int main(){
    printf("hell world!\n");
}
```

在LINUX下只需要执行以下命令：

```shell
gcc hello.c  #编译
./a.out      #执行
hello world!
```

虽然在LINUX中我们只需要一条gcc命令就完成了编译，但是编译的完整过程有四步才会生成可执行的文件。四步操作依次：1.预处理，2.编译，3.汇编，4.链接。

![](/img/post1img/bianyiing.png)

### 实例

用一个非常简单的例子进行讲解。

程序目录结构如下：

-test.c

-inc

--sum.h

--sum.c

对应代码如下：

```c
//test.c
#include <stdio.h>
#include "sum.h"
int main(){
    int a = 2;
    int b = 1;
    int sum = add(a,b);
    printf("a=%d, b=%d, a+b=%d\n",a,b,sum);
}
```

```c
//sum.h
#ifndef SUM_H
#define SUM_H
int add(int a,int b);
int sub(int a,int b);
#endif
```

```c
//sum.c
int add(int a,int b){
	return a+b;
}
int sub(int a,int b){
    return a-b;
}
```

#### 1.预处理

预处理是将include头文件以及宏定义替换成真正的内容，预处理之后同样是源代码类型，可直接查看，只是其中的内容多了很多。使用gcc命令进行预处理代码如下：

```shell
gcc -E -I ./inc test.c -o test.i 
```

-E 是让编译器预处理之后退出

-I 是指定头文件目录

-o 是指定输出文件名，不指定将在命令窗口直接查看内容

结果：

```shell
-rw-r--r--  1 root root   157 Jan 15 12:50 test.c
-rw-r--r--  1 root root 16299 Jan 15 12:56 test.i
```

前后对比文件大了很多，可直接文本格式打开能发现其中多了很多代码。

#### 2.编译

编译是将预处理之后的文本转换成特定的汇编代码。编译命令如下：

```shell
gcc -S -I ./inc test.c -o test.s
```

-S 是让编译器编译后停止，不进行之后的过程。

生成的test.s的内容如下：

```
	.file	"test.c"
	.text
	.section	.rodata
.LC0:
	.string	"a=%d, b=%d, a+b=%d\n"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$2, -4(%rbp)
	movl	$1, -8(%rbp)
	movl	-8(%rbp), %edx
	movl	-4(%rbp), %eax
	movl	%edx, %esi
	movl	%eax, %edi
	call	add@PLT
	movl	%eax, -12(%rbp)
	movl	-12(%rbp), %ecx
	movl	-8(%rbp), %edx
	movl	-4(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Debian 8.2.0-7) 8.2.0"
	.section	.note.GNU-stack,"",@progbits
```
#### 3.汇编

汇编过程就是将上面编译的汇编代码转换成机器码，产生的文件叫目标文件，其中的内容是二进制格式。使用的命令如下：

```shell
gcc -c test.s -o test.o
```

这里会为每个源文件生成一个目标文件。

#### 4.链接

链接过程是将多个目标文件所欲要的库文件（.so）链接成最终可执行的文件。命令如下：

```shell
ld -o test.out test.o inc/sum.o 
```

## ELF文件结构(PE)

### ELF文件分类

elf文件是linux下的可执行与链接文件，其主要格式分为三中：

1、可重定向文件：文件保存着代码和数据，用于和其他目标程序建立一个可执行文件。（常见后缀 .a, .o ）

2、可执行文件：文件保存着一个用来执行的程序。（如bash，gcc）

3、共享目标文件：共享库。文件保存在代码和数据。（常见后缀 .so）

### 结构介绍

使用一个简单实例介绍：

```c
//elf.c
#include <stdio.h>
int a = 10;
int b;

void func(int sum){
    printf("%d\n",sum);
}

void main(){
    static int c = 20;
    static int d;
    int e = 30;
    int f;
    func(a+c+e);
}
```

首先用颜色对应的方法来表示这段代码的结构图：

![](/img/post1img/elf.png)

通过结构图可以轻松看出代码块在文件中的分布情况。在这个被简化的文件结构图中，开始是一个“文件头”之后分别是代码段、数据段和.bss段。源代码编译过后，执行语句变成机器指令，保存在.text段中；已经初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量则放在.bss段。至于局部动态变量会存在代码段。

通过一段话一张对比图很简单就弄清楚了一个elf文件结构，但是在实际中往往还会存在很多段，但是我们只需要知道这几个段就够了，至于其他段可以使用objdump来查看完整的文件结构。有兴趣或者必要的时候可以自行查看。

```shell
objdump -h elf   //elf为上举例代码编译
```

结果：

```shell
elf：     文件格式 elf64-x86-64

节：
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  0000000000400238  0000000000400238  00000238  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.ABI-tag 00000020  0000000000400254  0000000000400254  00000254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.gnu.build-id 00000024  0000000000400274  0000000000400274  00000274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .gnu.hash     0000001c  0000000000400298  0000000000400298  00000298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynsym       00000060  00000000004002b8  00000000004002b8  000002b8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dynstr       0000003f  0000000000400318  0000000000400318  00000318  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .gnu.version  00000008  0000000000400358  0000000000400358  00000358  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .gnu.version_r 00000020  0000000000400360  0000000000400360  00000360  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rela.dyn     00000018  0000000000400380  0000000000400380  00000380  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rela.plt     00000030  0000000000400398  0000000000400398  00000398  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .init         0000001a  00000000004003c8  00000000004003c8  000003c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          00000030  00000000004003f0  00000000004003f0  000003f0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt.got      00000008  0000000000400420  0000000000400420  00000420  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text         000001c2  0000000000400430  0000000000400430  00000430  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini         00000009  00000000004005f4  00000000004005f4  000005f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata       00000008  0000000000400600  0000000000400600  00000600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .eh_frame_hdr 0000003c  0000000000400608  0000000000400608  00000608  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 17 .eh_frame     00000114  0000000000400648  0000000000400648  00000648  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 18 .init_array   00000008  0000000000600e10  0000000000600e10  00000e10  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 19 .fini_array   00000008  0000000000600e18  0000000000600e18  00000e18  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 20 .jcr          00000008  0000000000600e20  0000000000600e20  00000e20  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 21 .dynamic      000001d0  0000000000600e28  0000000000600e28  00000e28  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 22 .got          00000008  0000000000600ff8  0000000000600ff8  00000ff8  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 23 .got.plt      00000028  0000000000601000  0000000000601000  00001000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 24 .data         00000018  0000000000601028  0000000000601028  00001028  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 25 .bss          00000010  0000000000601040  0000000000601040  00001040  2**2
                  ALLOC
 26 .comment      00000035  0000000000000000  0000000000000000  00001040  2**0
                  CONTENTS, READONLY
```

## 总结

经过分解gcc编译每个过程，清楚一个程序的编译过程，此文章主要根据的是文件生成类型进行分析。而不是详细的分析编译器编译文件过程，编译器编译文件过程需要更多编译原理的知识，但是在目前考虑范围中，不需要接触到。之后又简单的介绍elf文件结构，在之后修改程序时能更好的理解。