---
layout: post
title: CTF-逆向PWN总结01
categories: 
 - CTF
 - 二进制
permalink: /posts/1
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# 逆向基础总结

## C语言编译过程

主要通过LINUX下C语言编译过程为例。

编写一个最简单的例子：

```c
//hello.c
#include <stdio.h>
int main(){
    printf("hell world!\n");
}
```

在LINUX下只需要执行以下命令：

```shell
gcc hello.c  #编译
./a.out      #执行
hello world!
```

虽然在LINUX中我们只需要一条gcc命令就完成了编译，但是编译的完整过程有四步才会生成可执行的文件。四步操作依次：1.预处理，2.编译，3.汇编，4.链接。

![](/img/post1img/bianyiing.png)

## 实例

用一个非常简单的例子进行讲解。

程序目录结构如下：

-test.c

-inc

--sum.h

--sum.c

对应代码如下：

```c
//test.c
#include <stdio.h>
#include "sum.h"
int main(){
    int a = 2;
    int b = 1;
    int sum = add(a,b);
    printf("a=%d, b=%d, a+b=%d\n",a,b,sum);
}
```

```c
//sum.h
#ifndef SUM_H
#define SUM_H
int add(int a,int b);
int sub(int a,int b);
#endif
```

```c
//sum.c
int add(int a,int b){
	return a+b;
}
int sub(int a,int b){
    return a-b;
}
```

### 1.预处理

预处理是将include头文件以及宏定义替换成真正的内容，预处理之后同样是源代码类型，可直接查看，只是其中的内容多了很多。使用gcc命令进行预处理代码如下：

```shell
gcc -E -I ./inc test.c -o test.i 
```

-E 是让编译器预处理之后退出

-I 是指定头文件目录

-o 是指定输出文件名，不指定将在命令窗口直接查看内容

结果：

```shell
-rw-r--r--  1 root root   157 Jan 15 12:50 test.c
-rw-r--r--  1 root root 16299 Jan 15 12:56 test.i
```

前后对比文件大了很多，可直接文本格式打开能发现其中多了很多代码。

### 2.编译

编译是将预处理之后的文本转换成特定的汇编代码。编译命令如下：

```shell
gcc -S -I ./inc test.c -o test.s
```

-S 是让编译器编译后停止，不进行之后的过程。

生成的test.s的内容如下：

```
	.file	"test.c"
	.text
	.section	.rodata
.LC0:
	.string	"a=%d, b=%d, a+b=%d\n"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$2, -4(%rbp)
	movl	$1, -8(%rbp)
	movl	-8(%rbp), %edx
	movl	-4(%rbp), %eax
	movl	%edx, %esi
	movl	%eax, %edi
	call	add@PLT
	movl	%eax, -12(%rbp)
	movl	-12(%rbp), %ecx
	movl	-8(%rbp), %edx
	movl	-4(%rbp), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Debian 8.2.0-7) 8.2.0"
	.section	.note.GNU-stack,"",@progbits
```
### 3.汇编

汇编过程就是将上面编译的汇编代码转换成机器码，产生的文件叫目标文件，其中的内容是二进制格式。使用的命令如下：

```shell
gcc -c test.s -o test.o
```

这里会为每个源文件生成一个目标文件。

### 4.链接

链接过程是将多个目标文件所欲要的库文件（.so）链接成最终可执行的文件。命令如下：

```shell
ld -o test.out test.o inc/sum.o 
```

## 总结

经过分解gcc编译每个过程，清楚一个程序的编译过程，此文章主要根据的是文件生成类型进行分析。而不是详细的分析编译器编译文件过程，编译器编译文件过程需要更多编译原理的知识，但是在目前考虑范围中，不需要接触到。